import {Admin, Course, Score, User} from "@/app/models";
import {LINK_STATIC_URL} from "@/configs";
import {STATUS_ACTIVE} from "@/utils/helpers/constants";
import {FileUpload} from "@/utils/types";
import _ from "lodash";
import {Class} from "../models/class";

export async function getAllCourse() {
    const courses = await Course.find({
        deleted: false,
    });
    return {courses};
}

export async function getListCourse({q, page, per_page, field, sort_order}) {
    q = q ? {$regex: q, $options: "i"} : null;

    const filter = {
        ...(q && {$or: [{name: q}, {code: q}]}),
        deleted: false,
    };

    // S·ª≠ d·ª•ng populate ƒë·ªÉ l·∫•y th√¥ng tin c·ªßa creator
    const courses = await Course.find(filter)
        .skip((page - 1) * per_page)
        .limit(per_page)
        .sort({[field]: sort_order})
        .populate({
            path: "creator_id", // T√™n field li√™n k·∫øt v·ªõi User
            select: "_id name avatar", // Ch·ªçn c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
        })
        .populate({
            path: "updater_id", // T√™n field li√™n k·∫øt v·ªõi User
            select: "_id name avatar", // Ch·ªçn c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
        });
    // Map l·∫°i ƒë·ªÉ th√™m LINK_STATIC_URL v√†o t·ª´ng ·∫£nh c·ªßa course v√† avatar c·ªßa creator
    const coursesEdit = courses.map((course) => {
        const creator = course.creator_id; // L·∫•y th√¥ng tin c·ªßa creator
        const updater = course.updater_id; // L·∫•y th√¥ng tin c·ªßa updater
        let images_src = [];
        return {
            ...course._doc,
            images_src: (images_src = course.images.map((img) => LINK_STATIC_URL + img)),
            image_featured: _.isNumber(course.image_featured) && images_src[course.image_featured],
            creator: {
                _id: creator?._id,
                name: creator.name,
                avatar: creator.avatar ? LINK_STATIC_URL + creator.avatar : null, // Th√™m LINK_STATIC_URL v√†o avatar
            },
            updater: {
                _id: updater._id,
                name: updater.name,
                avatar: updater.avatar ? LINK_STATIC_URL + creator.avatar : null, // Th√™m LINK_STATIC_URL v√†o avatar
            },
        };
    });

    const total = await Course.countDocuments(filter);
    return {total, page, per_page, courses: coursesEdit};
}

export async function getListCourseForUser({q, page, per_page, field, sort_order}) {
    q = q ? {$regex: q, $options: "i"} : null;

    const filter = {
        ...(q && {$or: [{name: q}, {code: q}]}),
        deleted: false,
    };

    // Chuy·ªÉn sort_order th√†nh gi√° tr·ªã s·ªë
    const sortOrderValue = sort_order === "desc" ? -1 : 1;

    // Truy v·∫•n ƒë·ªÉ l·∫•y danh s√°ch Course
    const courses = await Course.aggregate([
        {$match: filter},
        {$sort: {[field]: sortOrderValue}}, // S·∫Øp x·∫øp theo tr∆∞·ªùng ƒë∆∞·ª£c cung c·∫•p v√† th·ª© t·ª±
        {$skip: (page - 1) * per_page},
        {$limit: per_page},
        {
            $lookup: {
                from: "classes", // B·∫£ng Class
                localField: "_id", // Kh√≥a ch√≠nh c·ªßa Course (_id)
                foreignField: "course_id", // Kh√≥a ngo·∫°i course_id trong Class
                as: "classes_info", // K·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o tr∆∞·ªùng "classes_info"
            },
        },
    ]);

    // X·ª≠ l√Ω c√°c k·∫øt qu·∫£, th√™m URL tƒ©nh v√†o c√°c h√¨nh ·∫£nh
    const coursesEdit = courses.map((pkg) => {
        let images_src = [];
        return {
            ...pkg,
            images_src: (images_src = pkg.images.map((img) => LINK_STATIC_URL + img)),
            image_featured: _.isNumber(pkg.image_featured) && images_src[pkg.image_featured],
            classes: pkg.classes_info
                .map((classItem) => ({
                    _id: classItem._id,
                    name: classItem.name,
                    code: classItem.code,
                    start_time: classItem.start_time,
                    end_time: classItem.end_time,
                    deleted: classItem.deleted,
                }))
                .filter((classItem) => !classItem.deleted), // L·ªçc c√°c l·ªõp kh√¥ng b·ªã x√≥a
        };
    });

    const total = await Course.countDocuments(filter);

    return {
        total,
        page,
        per_page,
        courses: coursesEdit,
    };
}

// Chi ti·∫øt
export async function getDetailsCourse(courseId) {
    const courseDetails = await Course.findOne({ _id: courseId, deleted: false });

    if (!courseDetails) return null;

    // G√°n ƒë∆∞·ªùng d·∫´n cho file v√† ·∫£nh
    courseDetails.file_record = courseDetails.file_record ? LINK_STATIC_URL + courseDetails.file_record : null;
    courseDetails.images = courseDetails.images.map((img) => LINK_STATIC_URL + img);

    // L·∫•y c√°c l·ªõp th·ªÉ thao c√≥ course_id b·∫±ng courseId
    const classes = await Class.find({ course_id: courseId, deleted: false }).lean();

    // Ki·ªÉm tra n·∫øu kh√¥ng c√≥ l·ªõp n√†o, g√°n classes l√† null
    if (classes.length === 0) {
        return {
            ...courseDetails.toObject(),
            classes: null, // Kh√¥ng c√≥ l·ªõp n√†o, g√°n null cho classes
        };
    }

    // Duy·ªát qua t·ª´ng l·ªõp ƒë·ªÉ l·∫•y th√¥ng tin hu·∫•n luy·ªán vi√™n
    for (const classItem of classes) {
        if (classItem.teacher_id) {
            // T√¨m hu·∫•n luy·ªán vi√™n c√≥ _id b·∫±ng v·ªõi teacher_id c·ªßa l·ªõp
            const teacher = await Admin.findOne({ _id: classItem.teacher_id, deleted: false }).lean();

            // N·∫øu t√¨m th·∫•y hu·∫•n luy·ªán vi√™n, th√™m v√†o th√¥ng tin hu·∫•n luy·ªán vi√™n v√† x·ª≠ l√Ω avatar
            if (teacher) {
                classItem.teacher = {
                    _id: teacher._id,
                    name: teacher.name,
                    avatar: teacher.avatar ? LINK_STATIC_URL + teacher.avatar : null,
                };
            } else {
                classItem.teacher = null; // N·∫øu kh√¥ng t√¨m th·∫•y hu·∫•n luy·ªán vi√™n, g√°n null
            }
        } else {
            classItem.teacher = null; // N·∫øu kh√¥ng c√≥ teacher_id, g√°n null
        }
    }

    return {
        ...courseDetails.toObject(),
        classes, // Tr·∫£ v·ªÅ danh s√°ch c√°c l·ªõp ho·∫∑c null n·∫øu kh√¥ng c√≥ l·ªõp n√†o
    };
}


export async function create(
    {name, description, images, image_featured, start_time, end_time, original_price, current_price},
    creator_id,
) {
    const lastCourse = await Course.findOne().sort({code: -1});
    let newCode = "C001";

    if (lastCourse) {
        const lastCode = lastCourse.code;
        const numberPart = parseInt(lastCode.slice(2), 10) + 1;
        newCode = `C${numberPart.toString().padStart(3, "0")}`;
    }

    images = await Promise.all(images.map((img) => img.save("images/courses")));

    const course = new Course({
        code: newCode,
        name,
        creator_id: creator_id._id,
        updater_id: creator_id._id,
        description,
        images,
        image_featured: images.length > 0 && _.isNumber(image_featured) ? image_featured : null,
        original_price,
        current_price,
        start_time,
        end_time,
        status: STATUS_ACTIVE.UNLOCK,
    });

    await course.save();

    return course;
}

export async function update(
    course,
    {name, description, images, image_featured, original_price, current_price, start_time, end_time, status},
    updater,
) {
    const keepImages = course.images.filter((img) => images.includes(img));
    const removeImages = course.images.filter((img) => !images.includes(img));

    images = images.filter((img) => img instanceof FileUpload).map((img) => img.save("images/courses"));

    const newImages = await Promise.all(images);

    for (const img of removeImages) {
        FileUpload.remove(img);
    }

    course.name = name;
    course.description = description;
    course.images = [...keepImages, ...newImages];
    course.image_featured = course.images.length > 0 && _.isNumber(image_featured) ? image_featured : null;
    course.start_time = start_time;
    course.end_time = end_time;
    course.current_price = current_price;
    course.original_price = original_price;
    course.updater_id = updater._id;
    course.status = status;

    const updateCourse = await course.save();
    console.log("üåà ~ updateCourse:", updateCourse);

    return course;
}

export async function remove(pkg) {
    // ƒê√°nh d·∫•u kh√≥a t·∫≠p l√† ƒë√£ x√≥a
    pkg.deleted = true;
    await pkg.save();

    // T√¨m t·∫•t c·∫£ l·ªõp th·ªÉ thao c√≥ course_id b·∫±ng v·ªõi pkg._id
    const classes = await Class.find({ course_id: pkg._id });

    // L·∫•y ra m·∫£ng c√°c _id c·ªßa l·ªõp th·ªÉ thao
    const classIds = classes.map((cls) => cls._id);

    // X√≥a c√°c b·∫£n ghi trong b·∫£ng Score c√≥ class_id n·∫±m trong m·∫£ng classIds
    await Score.deleteMany({ class_id: { $in: classIds } });

    // C·∫≠p nh·∫≠t deleted: true cho c√°c l·ªõp th·ªÉ thao c√≥ course_id b·∫±ng pkg._id
    await Class.updateMany({ _id: { $in: classIds } }, { deleted: true });

    return { message: "Classes and related scores have been processed." };
}


export async function highlightedItem(pkg) {
    await Course.updateMany({deleted: false}, {is_highlight: false});
    await Course.updateOne({_id: pkg._id}, {is_highlight: true});
}

// L·∫•y nh·ªØng l·ªõp th·ªÉ thao thu·ªôc kh√≥a t·∫≠p
export async function getViewClassOf(courseId) {
    const courseDetails = await Course.findOne({ _id: courseId, deleted: false });

    if (!courseDetails) return null;

    // G√°n ƒë∆∞·ªùng d·∫´n cho file v√† ·∫£nh
    courseDetails.file_record = courseDetails.file_record ? LINK_STATIC_URL + courseDetails.file_record : null;
    courseDetails.images = courseDetails.images.map((img) => LINK_STATIC_URL + img);

    // L·∫•y c√°c l·ªõp th·ªÉ thao c√≥ course_id b·∫±ng courseId
    const classes = await Class.find({ course_id: courseId, deleted: false }).lean();

    // Ki·ªÉm tra n·∫øu kh√¥ng c√≥ l·ªõp n√†o, g√°n classes l√† null
    if (classes.length === 0) {
        return {
            ...courseDetails.toObject(),
            classes: null, // Kh√¥ng c√≥ l·ªõp n√†o, g√°n null cho classes
        };
    }

    // Duy·ªát qua t·ª´ng l·ªõp ƒë·ªÉ l·∫•y th√¥ng tin hu·∫•n luy·ªán vi√™n v√† h·ªôi vi√™n
    for (const classItem of classes) {
        // L·∫•y th√¥ng tin hu·∫•n luy·ªán vi√™n n·∫øu c√≥ teacher_id
        if (classItem.teacher_id) {
            const teacher = await Admin.findOne({ _id: classItem.teacher_id, deleted: false }).lean();

            // N·∫øu t√¨m th·∫•y hu·∫•n luy·ªán vi√™n, th√™m v√†o th√¥ng tin hu·∫•n luy·ªán vi√™n v√† x·ª≠ l√Ω avatar
            if (teacher) {
                classItem.teacher = {
                    _id: teacher._id,
                    name: teacher.name,
                    email: teacher.email,
                    avatar: teacher.avatar ? LINK_STATIC_URL + teacher.avatar : null,
                };
            } else {
                classItem.teacher = null; // N·∫øu kh√¥ng t√¨m th·∫•y hu·∫•n luy·ªán vi√™n, g√°n null
            }
        } else {
            classItem.teacher = null; // N·∫øu kh√¥ng c√≥ teacher_id, g√°n null
        }

        // L·∫•y th√¥ng tin h·ªôi vi√™n d·ª±a tr√™n student_ids
        if (classItem.student_ids && classItem.student_ids.length > 0) {
            const students = await User.find({ _id: { $in: classItem.student_ids }, deleted: false })
                .select("_id name email avatar address phone gender code")
                .lean();

            // X·ª≠ l√Ω avatar cho t·ª´ng h·ªôi vi√™n
            classItem.student_of_class = students.map((student) => ({
                ...student,
                avatar: student.avatar ? LINK_STATIC_URL + student.avatar : null,
            }));
        } else {
            classItem.student_of_class = []; // N·∫øu kh√¥ng c√≥ h·ªôi vi√™n, tr·∫£ v·ªÅ m·∫£ng r·ªóng
        }
    }

    return {
        ...courseDetails.toObject(),
        classes, // Tr·∫£ v·ªÅ danh s√°ch c√°c l·ªõp
    };
}


// export async function getListCourse({q, page, per_page, field, sort_order}) {
//     q = q ? {$regex: q, $options: "i"} : null;

//     const filter = {
//         ...(q && {$or: [{name: q}, {code: q}]}),
//         deleted: false,
//     };

//     // S·ª≠ d·ª•ng populate ƒë·ªÉ l·∫•y th√¥ng tin c·ªßa creator
//     const courses = await Course.find(filter)
//         .skip((page - 1) * per_page)
//         .limit(per_page)
//         .sort({[field]: sort_order})
//         .populate({
//             path: "creator_id", // T√™n field li√™n k·∫øt v·ªõi User
//             select: "_id name avatar", // Ch·ªçn c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
//         })
//         .populate({
//             path: "updater_id", // T√™n field li√™n k·∫øt v·ªõi User
//             select: "_id name avatar", // Ch·ªçn c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
//         })
//         ;

//     // Map l·∫°i ƒë·ªÉ th√™m LINK_STATIC_URL v√†o t·ª´ng ·∫£nh c·ªßa course v√† avatar c·ªßa creator
//     const coursesEdit = courses.map((course) => {
//         const creator = course.creator_id; // L·∫•y th√¥ng tin c·ªßa creator
//         const updater = course.updater_id; // L·∫•y th√¥ng tin c·ªßa updater
//         let images_src = [];
//         return {
//             ...course._doc,
//             images_src: images_src = course.images.map((img) => LINK_STATIC_URL + img),
//             image_featured:
//             _.isNumber(course.image_featured) && images_src[course.image_featured],
//             creator: {
//                 _id: creator._id,
//                 name: creator.name,
//                 avatar: creator.avatar ? LINK_STATIC_URL + creator.avatar : null, // Th√™m LINK_STATIC_URL v√†o avatar
//             },
//             updater: {
//                 _id: updater._id,
//                 name: updater.name,
//                 avatar: updater.avatar ? LINK_STATIC_URL + creator.avatar : null, // Th√™m LINK_STATIC_URL v√†o avatar
//             }
//         };
//     });

//     const total = await Course.countDocuments(filter);
//     return {total, page, per_page, courses: coursesEdit};
// }
